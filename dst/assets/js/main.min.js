/*!
 * Useragnt
 * v0.3.1
 * 
 * Copyright (c) 2016 Yuichiroh Arai
 * Released under the MIT license
 * http://opensource.org/licenses/mit-license.php
 * 
 * detects: mobile, tablet, pc, windows, mac, linux, ios, android, edge, ie, safari, chrome, firefox, opera
!*/
"use strict";

!(function (e, o) {
  function i(e) {
    return n.indexOf(e) != -1;
  }function r(e) {
    var o = e.split("."),
        i = {};return i.str = e, i.float = parseFloat(e) || 0, i.major = o.length > 0 ? parseInt(o[0]) || 0 : 0, i.minor = o.length > 1 ? parseInt(o[1]) || 0 : 0, i.build = o.length > 2 ? parseInt(o[2]) || 0 : 0, i.revision = o.length > 3 ? parseInt(o[3]) || 0 : 0, i;
  }var a = {};a._detects = ["mobile", "tablet", "pc", "windows", "mac", "linux", "ios", "android", "edge", "ie", "safari", "chrome", "firefox", "opera"];var n = a.userAgent = e.navigator.userAgent.toLowerCase();a.mobile = i("iphone") || i("ipod") || i("android") && i("mobile") || i("windows") && i("phone") || i("firefox") && i("mobile") || i("blackberry"), a.tablet = i("ipad") || i("android") && !i("mobile") || i("windows") && i("touch") && !i("tablet pc") || i("firefox") && i("tablet") || i("kindle") || i("silk") || i("playbook"), a.pc = !i("iphone") && !i("ipod") && !i("ipad") && !i("android") && (!i("windows") || !i("phone") && (!i("touch") || i("tablet pc"))) && (!i("firefox") || !i("mobile") && !i("tablet")) && !i("blackberry") && !i("kindle") && !i("silk") && !i("playbook"), a.windows = i("windows"), a.mac = i("mac os x") && !i("iphone") && !i("ipad") && !i("ipod"), a.linux = i("linux") && !i("android"), a.ios = i("iphone") || i("ipad") || i("ipod"), a.ios && (a.ios = new Boolean(!0), n.match(/ os ([\d_]+)/g), a.ios.version = r(RegExp.$1.replace("_", "."))), a.android = i("android"), a.android && (a.android = new Boolean(!0), n.match(/android ([\d\.]+)/g), a.android.version = r(RegExp.$1)), a.edge = i("edge"), a.ie = i("trident") || i("msie"), a.safari = i("safari") && !i("android") && !i("edge") && !i("opera") && !i("opr") && !i("chrome"), a.chrome = i("chrome") && !i("edge") && !i("opera") && !i("opr"), a.chrome && (a.chrome = new Boolean(!0), n.match(/chrome\/([\d.]+)/g), a.chrome.version = r(RegExp.$1)), a.firefox = i("firefox") && !i("edge"), a.opera = i("opera") || i("opr");var d,
      t,
      s,
      l = a._classPrefix = "",
      p = o.documentElement,
      c = p.className;for (t = a._detects.length, d = 0; d < t; d++) s = a._detects[d], c += a[s] ? " " + l + s : " " + l + "no-" + s;p.className = c, e.Useragnt = a;
})(window, document);
/**
 * @author qiao / https://github.com/qiao
 * @author mrdoob / http://mrdoob.com
 * @author alteredq / http://alteredqualia.com/
 * @author WestLangley / http://github.com/WestLangley
 * @author erich666 / http://erichaines.com
 */

// This set of controls performs orbiting, dollying (zooming), and panning.
// Unlike TrackballControls, it maintains the "up" direction object.up (+Y by default).
//
//    Orbit - left mouse / touch: one finger move
//    Zoom - middle mouse, or mousewheel / touch: two finger spread or squish
//    Pan - right mouse, or arrow keys / touch: three finger swipe

'use strict';

THREE.OrbitControls = function (object, domElement) {

	this.object = object;

	this.domElement = domElement !== undefined ? domElement : document;

	// Set to false to disable this control
	this.enabled = true;

	// "target" sets the location of focus, where the object orbits around
	this.target = new THREE.Vector3();

	// How far you can dolly in and out ( PerspectiveCamera only )
	this.minDistance = 0;
	this.maxDistance = Infinity;

	// How far you can zoom in and out ( OrthographicCamera only )
	this.minZoom = 0;
	this.maxZoom = Infinity;

	// How far you can orbit vertically, upper and lower limits.
	// Range is 0 to Math.PI radians.
	this.minPolarAngle = 0; // radians
	this.maxPolarAngle = Math.PI; // radians

	// How far you can orbit horizontally, upper and lower limits.
	// If set, must be a sub-interval of the interval [ - Math.PI, Math.PI ].
	this.minAzimuthAngle = -Infinity; // radians
	this.maxAzimuthAngle = Infinity; // radians

	// Set to true to enable damping (inertia)
	// If damping is enabled, you must call controls.update() in your animation loop
	this.enableDamping = false;
	this.dampingFactor = 0.25;

	// This option actually enables dollying in and out; left as "zoom" for backwards compatibility.
	// Set to false to disable zooming
	this.enableZoom = true;
	this.zoomSpeed = 1.0;

	// Set to false to disable rotating
	this.enableRotate = true;
	this.rotateSpeed = 1.0;

	// Set to false to disable panning
	this.enablePan = true;
	this.keyPanSpeed = 7.0; // pixels moved per arrow key push

	// Set to true to automatically rotate around the target
	// If auto-rotate is enabled, you must call controls.update() in your animation loop
	this.autoRotate = false;
	this.autoRotateSpeed = 2.0; // 30 seconds per round when fps is 60

	// Set to false to disable use of the keys
	this.enableKeys = true;

	// The four arrow keys
	this.keys = { LEFT: 37, UP: 38, RIGHT: 39, BOTTOM: 40 };

	// Mouse buttons
	this.mouseButtons = { ORBIT: THREE.MOUSE.LEFT, ZOOM: THREE.MOUSE.MIDDLE, PAN: THREE.MOUSE.RIGHT };

	// for reset
	this.target0 = this.target.clone();
	this.position0 = this.object.position.clone();
	this.zoom0 = this.object.zoom;

	//
	// public methods
	//

	this.getPolarAngle = function () {

		return spherical.phi;
	};

	this.getAzimuthalAngle = function () {

		return spherical.theta;
	};

	this.reset = function () {

		scope.target.copy(scope.target0);
		scope.object.position.copy(scope.position0);
		scope.object.zoom = scope.zoom0;

		scope.object.updateProjectionMatrix();
		scope.dispatchEvent(changeEvent);

		scope.update();

		state = STATE.NONE;
	};

	// this method is exposed, but perhaps it would be better if we can make it private...
	this.update = (function () {

		var offset = new THREE.Vector3();

		// so camera.up is the orbit axis
		var quat = new THREE.Quaternion().setFromUnitVectors(object.up, new THREE.Vector3(0, 1, 0));
		var quatInverse = quat.clone().inverse();

		var lastPosition = new THREE.Vector3();
		var lastQuaternion = new THREE.Quaternion();

		return function update() {

			var position = scope.object.position;

			offset.copy(position).sub(scope.target);

			// rotate offset to "y-axis-is-up" space
			offset.applyQuaternion(quat);

			// angle from z-axis around y-axis
			spherical.setFromVector3(offset);

			if (scope.autoRotate && state === STATE.NONE) {

				rotateLeft(getAutoRotationAngle());
			}

			spherical.theta += sphericalDelta.theta;
			spherical.phi += sphericalDelta.phi;

			// restrict theta to be between desired limits
			spherical.theta = Math.max(scope.minAzimuthAngle, Math.min(scope.maxAzimuthAngle, spherical.theta));

			// restrict phi to be between desired limits
			spherical.phi = Math.max(scope.minPolarAngle, Math.min(scope.maxPolarAngle, spherical.phi));

			spherical.makeSafe();

			spherical.radius *= scale;

			// restrict radius to be between desired limits
			spherical.radius = Math.max(scope.minDistance, Math.min(scope.maxDistance, spherical.radius));

			// move target to panned location
			scope.target.add(panOffset);

			offset.setFromSpherical(spherical);

			// rotate offset back to "camera-up-vector-is-up" space
			offset.applyQuaternion(quatInverse);

			position.copy(scope.target).add(offset);

			scope.object.lookAt(scope.target);

			if (scope.enableDamping === true) {

				sphericalDelta.theta *= 1 - scope.dampingFactor;
				sphericalDelta.phi *= 1 - scope.dampingFactor;
			} else {

				sphericalDelta.set(0, 0, 0);
			}

			scale = 1;
			panOffset.set(0, 0, 0);

			// update condition is:
			// min(camera displacement, camera rotation in radians)^2 > EPS
			// using small-angle approximation cos(x/2) = 1 - x^2 / 8

			if (zoomChanged || lastPosition.distanceToSquared(scope.object.position) > EPS || 8 * (1 - lastQuaternion.dot(scope.object.quaternion)) > EPS) {

				scope.dispatchEvent(changeEvent);

				lastPosition.copy(scope.object.position);
				lastQuaternion.copy(scope.object.quaternion);
				zoomChanged = false;

				return true;
			}

			return false;
		};
	})();

	this.dispose = function () {

		scope.domElement.removeEventListener('contextmenu', onContextMenu, false);
		scope.domElement.removeEventListener('mousedown', onMouseDown, false);
		scope.domElement.removeEventListener('wheel', onMouseWheel, false);

		scope.domElement.removeEventListener('touchstart', onTouchStart, false);
		scope.domElement.removeEventListener('touchend', onTouchEnd, false);
		scope.domElement.removeEventListener('touchmove', onTouchMove, false);

		document.removeEventListener('mousemove', onMouseMove, false);
		document.removeEventListener('mouseup', onMouseUp, false);

		window.removeEventListener('keydown', onKeyDown, false);

		//scope.dispatchEvent( { type: 'dispose' } ); // should this be added here?
	};

	//
	// internals
	//

	var scope = this;

	var changeEvent = { type: 'change' };
	var startEvent = { type: 'start' };
	var endEvent = { type: 'end' };

	var STATE = { NONE: -1, ROTATE: 0, DOLLY: 1, PAN: 2, TOUCH_ROTATE: 3, TOUCH_DOLLY: 4, TOUCH_PAN: 5 };

	var state = STATE.NONE;

	var EPS = 0.000001;

	// current position in spherical coordinates
	var spherical = new THREE.Spherical();
	var sphericalDelta = new THREE.Spherical();

	var scale = 1;
	var panOffset = new THREE.Vector3();
	var zoomChanged = false;

	var rotateStart = new THREE.Vector2();
	var rotateEnd = new THREE.Vector2();
	var rotateDelta = new THREE.Vector2();

	var panStart = new THREE.Vector2();
	var panEnd = new THREE.Vector2();
	var panDelta = new THREE.Vector2();

	var dollyStart = new THREE.Vector2();
	var dollyEnd = new THREE.Vector2();
	var dollyDelta = new THREE.Vector2();

	function getAutoRotationAngle() {

		return 2 * Math.PI / 60 / 60 * scope.autoRotateSpeed;
	}

	function getZoomScale() {

		return Math.pow(0.95, scope.zoomSpeed);
	}

	function rotateLeft(angle) {

		sphericalDelta.theta -= angle;
	}

	function rotateUp(angle) {

		sphericalDelta.phi -= angle;
	}

	var panLeft = (function () {

		var v = new THREE.Vector3();

		return function panLeft(distance, objectMatrix) {

			v.setFromMatrixColumn(objectMatrix, 0); // get X column of objectMatrix
			v.multiplyScalar(-distance);

			panOffset.add(v);
		};
	})();

	var panUp = (function () {

		var v = new THREE.Vector3();

		return function panUp(distance, objectMatrix) {

			v.setFromMatrixColumn(objectMatrix, 1); // get Y column of objectMatrix
			v.multiplyScalar(distance);

			panOffset.add(v);
		};
	})();

	// deltaX and deltaY are in pixels; right and down are positive
	var pan = (function () {

		var offset = new THREE.Vector3();

		return function pan(deltaX, deltaY) {

			var element = scope.domElement === document ? scope.domElement.body : scope.domElement;

			if (scope.object instanceof THREE.PerspectiveCamera) {

				// perspective
				var position = scope.object.position;
				offset.copy(position).sub(scope.target);
				var targetDistance = offset.length();

				// half of the fov is center to top of screen
				targetDistance *= Math.tan(scope.object.fov / 2 * Math.PI / 180.0);

				// we actually don't use screenWidth, since perspective camera is fixed to screen height
				panLeft(2 * deltaX * targetDistance / element.clientHeight, scope.object.matrix);
				panUp(2 * deltaY * targetDistance / element.clientHeight, scope.object.matrix);
			} else if (scope.object instanceof THREE.OrthographicCamera) {

				// orthographic
				panLeft(deltaX * (scope.object.right - scope.object.left) / scope.object.zoom / element.clientWidth, scope.object.matrix);
				panUp(deltaY * (scope.object.top - scope.object.bottom) / scope.object.zoom / element.clientHeight, scope.object.matrix);
			} else {

				// camera neither orthographic nor perspective
				console.warn('WARNING: OrbitControls.js encountered an unknown camera type - pan disabled.');
				scope.enablePan = false;
			}
		};
	})();

	function dollyIn(dollyScale) {

		if (scope.object instanceof THREE.PerspectiveCamera) {

			scale /= dollyScale;
		} else if (scope.object instanceof THREE.OrthographicCamera) {

			scope.object.zoom = Math.max(scope.minZoom, Math.min(scope.maxZoom, scope.object.zoom * dollyScale));
			scope.object.updateProjectionMatrix();
			zoomChanged = true;
		} else {

			console.warn('WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.');
			scope.enableZoom = false;
		}
	}

	function dollyOut(dollyScale) {

		if (scope.object instanceof THREE.PerspectiveCamera) {

			scale *= dollyScale;
		} else if (scope.object instanceof THREE.OrthographicCamera) {

			scope.object.zoom = Math.max(scope.minZoom, Math.min(scope.maxZoom, scope.object.zoom / dollyScale));
			scope.object.updateProjectionMatrix();
			zoomChanged = true;
		} else {

			console.warn('WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.');
			scope.enableZoom = false;
		}
	}

	//
	// event callbacks - update the object state
	//

	function handleMouseDownRotate(event) {

		//console.log( 'handleMouseDownRotate' );

		rotateStart.set(event.clientX, event.clientY);
	}

	function handleMouseDownDolly(event) {

		//console.log( 'handleMouseDownDolly' );

		dollyStart.set(event.clientX, event.clientY);
	}

	function handleMouseDownPan(event) {

		//console.log( 'handleMouseDownPan' );

		panStart.set(event.clientX, event.clientY);
	}

	function handleMouseMoveRotate(event) {

		//console.log( 'handleMouseMoveRotate' );

		rotateEnd.set(event.clientX, event.clientY);
		rotateDelta.subVectors(rotateEnd, rotateStart);

		var element = scope.domElement === document ? scope.domElement.body : scope.domElement;

		// rotating across whole screen goes 360 degrees around
		rotateLeft(2 * Math.PI * rotateDelta.x / element.clientWidth * scope.rotateSpeed);

		// rotating up and down along whole screen attempts to go 360, but limited to 180
		rotateUp(2 * Math.PI * rotateDelta.y / element.clientHeight * scope.rotateSpeed);

		rotateStart.copy(rotateEnd);

		scope.update();
	}

	function handleMouseMoveDolly(event) {

		//console.log( 'handleMouseMoveDolly' );

		dollyEnd.set(event.clientX, event.clientY);

		dollyDelta.subVectors(dollyEnd, dollyStart);

		if (dollyDelta.y > 0) {

			dollyIn(getZoomScale());
		} else if (dollyDelta.y < 0) {

			dollyOut(getZoomScale());
		}

		dollyStart.copy(dollyEnd);

		scope.update();
	}

	function handleMouseMovePan(event) {

		//console.log( 'handleMouseMovePan' );

		panEnd.set(event.clientX, event.clientY);

		panDelta.subVectors(panEnd, panStart);

		pan(panDelta.x, panDelta.y);

		panStart.copy(panEnd);

		scope.update();
	}

	function handleMouseUp(event) {

		// console.log( 'handleMouseUp' );

	}

	function handleMouseWheel(event) {

		// console.log( 'handleMouseWheel' );

		if (event.deltaY < 0) {

			dollyOut(getZoomScale());
		} else if (event.deltaY > 0) {

			dollyIn(getZoomScale());
		}

		scope.update();
	}

	function handleKeyDown(event) {

		//console.log( 'handleKeyDown' );

		switch (event.keyCode) {

			case scope.keys.UP:
				pan(0, scope.keyPanSpeed);
				scope.update();
				break;

			case scope.keys.BOTTOM:
				pan(0, -scope.keyPanSpeed);
				scope.update();
				break;

			case scope.keys.LEFT:
				pan(scope.keyPanSpeed, 0);
				scope.update();
				break;

			case scope.keys.RIGHT:
				pan(-scope.keyPanSpeed, 0);
				scope.update();
				break;

		}
	}

	function handleTouchStartRotate(event) {

		//console.log( 'handleTouchStartRotate' );

		rotateStart.set(event.touches[0].pageX, event.touches[0].pageY);
	}

	function handleTouchStartDolly(event) {

		//console.log( 'handleTouchStartDolly' );

		var dx = event.touches[0].pageX - event.touches[1].pageX;
		var dy = event.touches[0].pageY - event.touches[1].pageY;

		var distance = Math.sqrt(dx * dx + dy * dy);

		dollyStart.set(0, distance);
	}

	function handleTouchStartPan(event) {

		//console.log( 'handleTouchStartPan' );

		panStart.set(event.touches[0].pageX, event.touches[0].pageY);
	}

	function handleTouchMoveRotate(event) {

		//console.log( 'handleTouchMoveRotate' );

		rotateEnd.set(event.touches[0].pageX, event.touches[0].pageY);
		rotateDelta.subVectors(rotateEnd, rotateStart);

		var element = scope.domElement === document ? scope.domElement.body : scope.domElement;

		// rotating across whole screen goes 360 degrees around
		rotateLeft(2 * Math.PI * rotateDelta.x / element.clientWidth * scope.rotateSpeed);

		// rotating up and down along whole screen attempts to go 360, but limited to 180
		rotateUp(2 * Math.PI * rotateDelta.y / element.clientHeight * scope.rotateSpeed);

		rotateStart.copy(rotateEnd);

		scope.update();
	}

	function handleTouchMoveDolly(event) {

		//console.log( 'handleTouchMoveDolly' );

		var dx = event.touches[0].pageX - event.touches[1].pageX;
		var dy = event.touches[0].pageY - event.touches[1].pageY;

		var distance = Math.sqrt(dx * dx + dy * dy);

		dollyEnd.set(0, distance);

		dollyDelta.subVectors(dollyEnd, dollyStart);

		if (dollyDelta.y > 0) {

			dollyOut(getZoomScale());
		} else if (dollyDelta.y < 0) {

			dollyIn(getZoomScale());
		}

		dollyStart.copy(dollyEnd);

		scope.update();
	}

	function handleTouchMovePan(event) {

		//console.log( 'handleTouchMovePan' );

		panEnd.set(event.touches[0].pageX, event.touches[0].pageY);

		panDelta.subVectors(panEnd, panStart);

		pan(panDelta.x, panDelta.y);

		panStart.copy(panEnd);

		scope.update();
	}

	function handleTouchEnd(event) {}

	//console.log( 'handleTouchEnd' );

	//
	// event handlers - FSM: listen for events and reset state
	//

	function onMouseDown(event) {

		if (scope.enabled === false) return;

		event.preventDefault();

		if (event.button === scope.mouseButtons.ORBIT) {

			if (scope.enableRotate === false) return;

			handleMouseDownRotate(event);

			state = STATE.ROTATE;
		} else if (event.button === scope.mouseButtons.ZOOM) {

			if (scope.enableZoom === false) return;

			handleMouseDownDolly(event);

			state = STATE.DOLLY;
		} else if (event.button === scope.mouseButtons.PAN) {

			if (scope.enablePan === false) return;

			handleMouseDownPan(event);

			state = STATE.PAN;
		}

		if (state !== STATE.NONE) {

			document.addEventListener('mousemove', onMouseMove, false);
			document.addEventListener('mouseup', onMouseUp, false);

			scope.dispatchEvent(startEvent);
		}
	}

	function onMouseMove(event) {

		if (scope.enabled === false) return;

		event.preventDefault();

		if (state === STATE.ROTATE) {

			if (scope.enableRotate === false) return;

			handleMouseMoveRotate(event);
		} else if (state === STATE.DOLLY) {

			if (scope.enableZoom === false) return;

			handleMouseMoveDolly(event);
		} else if (state === STATE.PAN) {

			if (scope.enablePan === false) return;

			handleMouseMovePan(event);
		}
	}

	function onMouseUp(event) {

		if (scope.enabled === false) return;

		handleMouseUp(event);

		document.removeEventListener('mousemove', onMouseMove, false);
		document.removeEventListener('mouseup', onMouseUp, false);

		scope.dispatchEvent(endEvent);

		state = STATE.NONE;
	}

	function onMouseWheel(event) {

		if (scope.enabled === false || scope.enableZoom === false || state !== STATE.NONE && state !== STATE.ROTATE) return;

		event.preventDefault();
		event.stopPropagation();

		handleMouseWheel(event);

		scope.dispatchEvent(startEvent); // not sure why these are here...
		scope.dispatchEvent(endEvent);
	}

	function onKeyDown(event) {

		if (scope.enabled === false || scope.enableKeys === false || scope.enablePan === false) return;

		handleKeyDown(event);
	}

	function onTouchStart(event) {

		if (scope.enabled === false) return;

		switch (event.touches.length) {

			case 1:
				// one-fingered touch: rotate

				if (scope.enableRotate === false) return;

				handleTouchStartRotate(event);

				state = STATE.TOUCH_ROTATE;

				break;

			case 2:
				// two-fingered touch: dolly

				if (scope.enableZoom === false) return;

				handleTouchStartDolly(event);

				state = STATE.TOUCH_DOLLY;

				break;

			case 3:
				// three-fingered touch: pan

				if (scope.enablePan === false) return;

				handleTouchStartPan(event);

				state = STATE.TOUCH_PAN;

				break;

			default:

				state = STATE.NONE;

		}

		if (state !== STATE.NONE) {

			scope.dispatchEvent(startEvent);
		}
	}

	function onTouchMove(event) {

		if (scope.enabled === false) return;

		event.preventDefault();
		event.stopPropagation();

		switch (event.touches.length) {

			case 1:
				// one-fingered touch: rotate

				if (scope.enableRotate === false) return;
				if (state !== STATE.TOUCH_ROTATE) return; // is this needed?...

				handleTouchMoveRotate(event);

				break;

			case 2:
				// two-fingered touch: dolly

				if (scope.enableZoom === false) return;
				if (state !== STATE.TOUCH_DOLLY) return; // is this needed?...

				handleTouchMoveDolly(event);

				break;

			case 3:
				// three-fingered touch: pan

				if (scope.enablePan === false) return;
				if (state !== STATE.TOUCH_PAN) return; // is this needed?...

				handleTouchMovePan(event);

				break;

			default:

				state = STATE.NONE;

		}
	}

	function onTouchEnd(event) {

		if (scope.enabled === false) return;

		handleTouchEnd(event);

		scope.dispatchEvent(endEvent);

		state = STATE.NONE;
	}

	function onContextMenu(event) {

		event.preventDefault();
	}

	//

	scope.domElement.addEventListener('contextmenu', onContextMenu, false);

	scope.domElement.addEventListener('mousedown', onMouseDown, false);
	scope.domElement.addEventListener('wheel', onMouseWheel, false);

	scope.domElement.addEventListener('touchstart', onTouchStart, false);
	scope.domElement.addEventListener('touchend', onTouchEnd, false);
	scope.domElement.addEventListener('touchmove', onTouchMove, false);

	window.addEventListener('keydown', onKeyDown, false);

	// force an update at start

	this.update();
};

THREE.OrbitControls.prototype = Object.create(THREE.EventDispatcher.prototype);
THREE.OrbitControls.prototype.constructor = THREE.OrbitControls;

Object.defineProperties(THREE.OrbitControls.prototype, {

	center: {

		get: function get() {

			console.warn('THREE.OrbitControls: .center has been renamed to .target');
			return this.target;
		}

	},

	// backward compatibility

	noZoom: {

		get: function get() {

			console.warn('THREE.OrbitControls: .noZoom has been deprecated. Use .enableZoom instead.');
			return !this.enableZoom;
		},

		set: function set(value) {

			console.warn('THREE.OrbitControls: .noZoom has been deprecated. Use .enableZoom instead.');
			this.enableZoom = !value;
		}

	},

	noRotate: {

		get: function get() {

			console.warn('THREE.OrbitControls: .noRotate has been deprecated. Use .enableRotate instead.');
			return !this.enableRotate;
		},

		set: function set(value) {

			console.warn('THREE.OrbitControls: .noRotate has been deprecated. Use .enableRotate instead.');
			this.enableRotate = !value;
		}

	},

	noPan: {

		get: function get() {

			console.warn('THREE.OrbitControls: .noPan has been deprecated. Use .enablePan instead.');
			return !this.enablePan;
		},

		set: function set(value) {

			console.warn('THREE.OrbitControls: .noPan has been deprecated. Use .enablePan instead.');
			this.enablePan = !value;
		}

	},

	noKeys: {

		get: function get() {

			console.warn('THREE.OrbitControls: .noKeys has been deprecated. Use .enableKeys instead.');
			return !this.enableKeys;
		},

		set: function set(value) {

			console.warn('THREE.OrbitControls: .noKeys has been deprecated. Use .enableKeys instead.');
			this.enableKeys = !value;
		}

	},

	staticMoving: {

		get: function get() {

			console.warn('THREE.OrbitControls: .staticMoving has been deprecated. Use .enableDamping instead.');
			return !this.enableDamping;
		},

		set: function set(value) {

			console.warn('THREE.OrbitControls: .staticMoving has been deprecated. Use .enableDamping instead.');
			this.enableDamping = !value;
		}

	},

	dynamicDampingFactor: {

		get: function get() {

			console.warn('THREE.OrbitControls: .dynamicDampingFactor has been renamed. Use .dampingFactor instead.');
			return this.dampingFactor;
		},

		set: function set(value) {

			console.warn('THREE.OrbitControls: .dynamicDampingFactor has been renamed. Use .dampingFactor instead.');
			this.dampingFactor = value;
		}

	}

});
"use strict";

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Analyzer = (function () {
  function Analyzer(audio, smoothTime, scale) {
    _classCallCheck(this, Analyzer);

    this.audio = audio;
    this.controls = new Controls(this);

    this.scale = scale;

    this.audioContext = this.audio.audioContext;
    this.analyser = this.audioContext.createAnalyser();
    this.analyser.fftSize = 2048;
    this.frequencyNum = 1024;
    this.hz = 22028;
    this.analyser.smoothingTimeConstant = smoothTime;

    this.frequencyArray = [];

    this.distLength_1 = 120 * 2;
    this.distLength_2 = 60 * 2;

    this.setRange();

    this.level = 5;

    this.avrBass = 0;
  }

  _createClass(Analyzer, [{
    key: "setRange",
    value: function setRange() {
      this.minHz = 1;
      this.maxHz = this.controls.props.end;

      this.sourceStart = Math.ceil(this.frequencyNum * this.minHz / this.hz);
      this.sourceEnd = Math.round(this.frequencyNum * this.maxHz / this.hz);
      this.sourceLength = this.sourceEnd - this.sourceStart + 1;

      this.adjustOffset = Math.round(this.sourceLength * 0.12);

      this.interval_1 = (this.sourceLength - 1) / (this.distLength_1 - 1);
      this.interval_2 = (this.sourceLength - 1) / (this.distLength_2 - 1);
    }
  }, {
    key: "adjustFrequency",
    value: function adjustFrequency(i, avr) {
      var f = Math.max(0, this.spectrums[this.sourceStart + i] - avr) * this.scale;
      var offset = i - this.sourceStart;

      var ratio = offset / this.adjustOffset;

      f *= Math.max(0, Math.min(1, 5 / 6 * (ratio - 1) * (ratio - 1) * (ratio - 1) + 1));

      return f;
    }
  }, {
    key: "update",
    value: function update() {
      this.frequencyArray = [];

      var spectrums = new Float32Array(this.frequencyNum);

      if (this.audio.isReady) {
        this.analyser.getFloatFrequencyData(spectrums);
      }

      this.spectrums = spectrums;

      this.avr = 0;
      this.avrBass = 0;

      for (var i = this.sourceStart; i <= this.sourceEnd; i++) {
        this.avr += this.spectrums[i];
        if (i < 6) this.avrBass += this.spectrums[i];
      }

      this.avr /= this.sourceLength;
      this.avrBass /= 6;
      // console.log(this.avrBass);

      this.avr = !this.audio.isReady || this.avr === 0 ? this.avr : Math.min(-40, Math.max(this.avr, -60));
      this.avrBass = !this.audio.isReady || this.avrBass === 0 ? this.avrBass : Math.max(-60, this.avrBass);

      this.createArray(this.distLength_1, this.interval_1);
      this.createArray(this.distLength_2, this.interval_2, true);
    }
  }, {
    key: "createArray",
    value: function createArray(num, interval, isReverse) {
      if (!isReverse) {
        for (var i = 0; i < num; i++) {
          this.calcFrequency(num, interval, i);
        }
      } else {
        for (var i = num - 1; i >= 0; i--) {
          this.calcFrequency(num, interval, i);
        }
      }
    }
  }, {
    key: "calcFrequency",
    value: function calcFrequency(num, interval, i) {
      var n1 = Math.floor(i * interval);
      var n2 = n1 + 1;
      var n0 = Math.abs(n1 - 1);
      var n3 = n1 + 2;

      n2 = n2 > this.sourceLength - 1 ? (this.sourceLength - 1) * 2 - n2 : n2;
      n3 = n3 > this.sourceLength - 1 ? (this.sourceLength - 1) * 2 - n3 : n3;

      var p0 = this.adjustFrequency(n0, this.avr);
      var p1 = this.adjustFrequency(n1, this.avr);
      var p2 = this.adjustFrequency(n2, this.avr);
      var p3 = this.adjustFrequency(n3, this.avr);

      var mu = i * interval - n1;

      var targetFrequency = this.controls.props.isCubic ? this.cubic(mu, p0, p1, p2, p3) : this.linear(mu, p1, p2);

      targetFrequency = Math.max(0, targetFrequency);
      this.frequencyArray.push(targetFrequency * this.controls.props.scaleSize / 10);
    }
  }, {
    key: "cubic",
    value: function cubic(mu, p0, p1, p2, p3) {
      var mu2 = mu * mu;

      var a0 = -0.5 * p0 + 1.5 * p1 - 1.5 * p2 + 0.5 * p3;
      var a1 = p0 - 2.5 * p1 + 2 * p2 - 0.5 * p3;
      var a2 = -0.5 * p0 + 0.5 * p2;

      return a0 * mu * mu2 + a1 * mu2 + a2 * mu + p1;
    }
  }, {
    key: "linear",
    value: function linear(mu, p1, p2) {
      return p1 * (1 - mu) + p2 * mu;
    }
  }]);

  return Analyzer;
})();
'use strict';

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

var Audio = (function () {
  function Audio(webgl) {
    _classCallCheck(this, Audio);

    this.webgl = webgl;
    this.torus = this.webgl.torus;
    this.audioContext = window.AudioContext ? new AudioContext() : new webkitAudioContext();
    this.fileReader = new FileReader();
    this.isReady = false;
    this.count = 0;
  }

  _createClass(Audio, [{
    key: 'init',
    value: function init() {
      this.analyzer = new Analyzer(this, 0.8, 3.5);

      this.render();

      document.getElementById('file').addEventListener('change', (function (e) {
        this.fileReader.readAsArrayBuffer(e.target.files[0]);
      }).bind(this));

      var _this = this;

      this.fileReader.onload = function () {
        _this.audioContext.decodeAudioData(_this.fileReader.result, function (buffer) {
          if (_this.source) {
            _this.source.stop();
          }
          _this.source = _this.audioContext.createBufferSource();
          _this.source.buffer = buffer;

          _this.source.loop = true;

          _this.connectNode(buffer);

          _this.isReady = true;
        });
      };
    }
  }, {
    key: 'connectNode',
    value: function connectNode() {
      this.source.loop = true;

      this.source.connect(this.analyzer.analyser);

      this.source.connect(this.audioContext.destination);
      this.source.start(0);
    }
  }, {
    key: 'render',
    value: function render() {
      this.analyzer.update();
      this.webgl.render();
      requestAnimationFrame(this.render.bind(this));
    }
  }]);

  return Audio;
})();
"use strict";

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Controls = (function () {
  function Controls(analyzer) {
    _classCallCheck(this, Controls);

    this.analyzer = analyzer;
    this.props = {
      // start: 1,
      end: 700,
      isCubic: true,
      scaleSize: 1 / 5 * 10
    };
    this.init();
  }

  _createClass(Controls, [{
    key: "init",
    value: function init() {
      this.gui = new dat.GUI({ width: 300 });
      // this.gui.remember(this.controls);

      // this.gui.add(this.props, "start", 1, 90).name("start frequency").onChange(this.changeFunc.bind(this));
      this.gui.add(this.props, "end", 100, 6000).name("end frequency").onChange(this.changeFunc.bind(this));
      this.gui.add(this.props, "isCubic").name("cubic interpolation");
      this.gui.add(this.props, "scaleSize", 1 / 7 * 10, 1 / 2 * 10).name("scale size");
    }
  }, {
    key: "changeFunc",
    value: function changeFunc(value) {

      this.analyzer.setRange();
    }
  }]);

  return Controls;
})();
"use strict";

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var ResizeWatch = (function () {
  function ResizeWatch() {
    _classCallCheck(this, ResizeWatch);

    this.instances = [];

    this.width = this._width = document.body.clientWidth;
    this.height = this._height = window.innerHeight;
    this.aspect = this.width / this.height;

    window.onresize = (function () {
      if (this.instances.length === 0) return;

      this.width = document.body.clientWidth;
      this.height = window.innerHeight;
      this.aspect = this.width / this.height;

      for (var i = 0; i < this.instances.length; i++) {
        this.instances[i].resizeUpdate();
      }
    }).bind(this);
  }

  _createClass(ResizeWatch, [{
    key: "register",
    value: function register(instance) {
      this.instances.push(instance);
    }
  }]);

  return ResizeWatch;
})();

window.ResizeWatch = new ResizeWatch();
"use strict";

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Torus = (function () {
  function Torus(webgl) {
    _classCallCheck(this, Torus);

    this.webgl = webgl;
    this.init();
  }

  _createClass(Torus, [{
    key: "init",
    value: function init() {
      var geometry = this.createGeometry();

      this.uniforms = {
        uRadius: { type: "f", value: this.radius },
        uTick: { type: "f", value: 0 }
      };

      var material = new THREE.ShaderMaterial({
        vertexShader: this.webgl.vertShader[0],
        fragmentShader: this.webgl.fragShader[0],
        uniforms: this.uniforms,
        shading: THREE.FlatShading,
        side: THREE.DoubleSide

      });

      var torus = new THREE.Mesh(geometry, material);
      torus.frustumCulled = false;

      this.webgl.scene.add(torus);
    }
  }, {
    key: "createGeometry",
    value: function createGeometry() {
      this.geometry = new THREE.BufferGeometry();

      this.radius = 180 * 1.1;

      var tube = 1.5 * 1.1;

      this.radialSegments = 18;

      this.tubularSegments = 360;

      this.orderNumArray = [];
      var vertices = [];
      var normals = [];
      var radians = [];
      var uvs = [];
      var indices = [];

      for (var j = 0; j <= this.radialSegments; j++) {
        for (var i = 0; i <= this.tubularSegments; i++) {

          this.orderNumArray.push(i);

          var u = i / this.tubularSegments * Math.PI * 2;
          var v = j / this.radialSegments * Math.PI * 2;

          radians.push(u);

          // vertex

          var vertex = {};

          vertex.x = (this.radius + tube * Math.cos(v)) * Math.cos(u);
          vertex.y = (this.radius + tube * Math.cos(v)) * Math.sin(u);
          vertex.z = tube * Math.sin(v);

          vertices.push(vertex.x, vertex.y, vertex.z);

          // normal

          var center = {};

          center.x = this.radius * Math.cos(u);
          center.y = this.radius * Math.sin(u);

          var normal = {};

          normal.x = vertex.x - center.x;
          normal.y = vertex.y - center.y;
          normal.z = vertex.z - center.z;

          var normalRatio = Math.sqrt(normal.x * normal.x + normal.y * normal.y + normal.z * normal.z);

          // normal.subVectors( , center ).normalize();

          normals.push(normal.x / normalRatio, normal.y / normalRatio, normal.z / normalRatio);

          // uv

          uvs.push(i / this.tubularSegments);
          uvs.push(j / this.radialSegments);
        }
      }

      // indices
      for (var j = 1; j <= this.radialSegments; j++) {
        for (var i = 1; i <= this.tubularSegments; i++) {

          // indices

          var a = (this.tubularSegments + 1) * j + i - 1;
          var b = (this.tubularSegments + 1) * (j - 1) + i - 1;
          var c = (this.tubularSegments + 1) * (j - 1) + i;
          var d = (this.tubularSegments + 1) * j + i;

          // faces
          indices.push(a, b, d);
          indices.push(b, c, d);
        }
      }

      this.radians = new THREE.Float32BufferAttribute(radians, 1);

      this.indices = new (indices.length > 65535 ? THREE.Uint32BufferAttribute : THREE.Uint16BufferAttribute)(indices, 1);
      this.positions = new THREE.Float32BufferAttribute(vertices, 3);
      this.normals = new THREE.Float32BufferAttribute(normals, 3);

      this.uvs = new THREE.Float32BufferAttribute(uvs, 2);

      this.frequencies = new THREE.BufferAttribute(new Float32Array((this.radialSegments + 1) * (this.tubularSegments + 1)), 1);

      this.geometry.setIndex(this.indices);
      this.geometry.addAttribute("position", this.positions);
      this.geometry.addAttribute("normal", this.normals);
      this.geometry.addAttribute("uv", this.uvs);

      this.geometry.addAttribute("aFrequency", this.frequencies);
      this.geometry.addAttribute("aRadian", this.radians);

      return this.geometry;
    }
  }, {
    key: "render",
    value: function render() {
      this.uniforms.uTick.value++;
      var spectrums = this.webgl.audio.analyzer.frequencyArray;

      var aFrequency = this.geometry.attributes.aFrequency;
      aFrequency.needsUpdate = true;

      for (var i = 0; i < aFrequency.count; i++) {
        var num = this.orderNumArray[i];
        if (num === this.tubularSegments) num = 0;
        var spectrum = spectrums[num];
        aFrequency.array[i] = spectrum;
      }
    }
  }]);

  return Torus;
})();
"use strict";

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Webgl = (function () {
  function Webgl() {
    _classCallCheck(this, Webgl);

    this.vertShader = ["assets/glsl/torus.vert"];

    this.fragShader = ["assets/glsl/torus.frag"];

    this.shaderLength = this.vertShader.length + this.fragShader.length;
    this.shaderCount = 0;

    for (var i = 0; i < this.vertShader.length; i++) {
      this.importShader_vert(i);
    }

    for (var i = 0; i < this.fragShader.length; i++) {
      this.importShader_frag(i);
    }
  }

  _createClass(Webgl, [{
    key: "importShader_vert",
    value: function importShader_vert(i) {

      var myRequest = new XMLHttpRequest();

      var _this = this;
      myRequest.onreadystatechange = function () {
        if (myRequest.readyState === 4) {
          _this.vertShader[i] = myRequest.response;
          _this.completeShaderLoad();
        }
      };

      myRequest.open("GET", this.vertShader[i], true);
      myRequest.send();
    }
  }, {
    key: "importShader_frag",
    value: function importShader_frag(i) {

      var myRequest = new XMLHttpRequest();

      var _this = this;
      myRequest.onreadystatechange = function () {
        if (myRequest.readyState === 4) {
          _this.fragShader[i] = myRequest.response;

          _this.completeShaderLoad();
        }
      };

      myRequest.open("GET", this.fragShader[i], true);
      myRequest.send();
    }
  }, {
    key: "completeShaderLoad",
    value: function completeShaderLoad() {
      this.shaderCount++;

      if (this.shaderCount === this.shaderLength) {
        this.isShaderComplete = true;
        this.init();
      }
    }
  }, {
    key: "init",
    value: function init() {
      // console.log(this.vertShader, this.fragShader);
      ResizeWatch.register(this);

      this.width = 1600;
      this.height = 1600;
      this.aspect = this.width / this.height;

      this.scene = new THREE.Scene();

      this.setProps();

      this.camera = new THREE.PerspectiveCamera(this.props.fov, this.props.aspect, this.props.near, this.props.far);
      var cameraZ = this.props.height / 2 / Math.tan(45 * Math.PI / 180 / 2);

      this.camera.position.set(0, 0, cameraZ / 1.8);

      this.camera.lookAt(this.scene.position);

      this.renderer = new THREE.WebGLRenderer({
        antialias: true,
        alpha: true
      });

      var ratio = 1.5;

      this.renderer.setPixelRatio(ratio);

      this.renderer.setClearColor(0xffffff, 1);
      this.renderer.setSize(ResizeWatch.width, ResizeWatch.height);

      this.div = document.getElementById("wrapper");
      this.div.appendChild(this.renderer.domElement);

      this.torus = new Torus(this);

      var control = new THREE.OrbitControls(this.camera, this.renderer.domElement);

      this.audio = new Audio(this);
      this.audio.init();
      this.resizeUpdate();
    }
  }, {
    key: "setProps",
    value: function setProps() {
      var width = ResizeWatch.width;
      var height = ResizeWatch.height;
      var aspect = width / height;

      this.props = {
        width: width,
        height: height,
        aspect: aspect,
        fov: 45,
        left: -width / 2,
        right: width / 2,
        top: height / 2,
        bottom: -height / 2,
        near: 0.1,
        far: 10000,
        parent: document.getElementById("wrapper")
      };
    }
  }, {
    key: "resizeUpdate",
    value: function resizeUpdate() {
      this.setProps();
      this.renderer.setSize(this.props.width, this.props.height);

      this.camera.aspect = this.props.aspect;

      var cameraZ = this.props.height / 2 / Math.tan(this.props.fov * Math.PI / 180 / 2);

      this.camera.position.set(0, 0, cameraZ / 1.8);

      this.camera.lookAt(this.scene.position);

      this.camera.updateProjectionMatrix();
    }
  }, {
    key: "render",
    value: function render() {
      if (this.uniforms) this.uniforms.uTick.value += 1;
      this.renderer.render(this.scene, this.camera);
      this.torus.render();
      // this.effect.render();
    }
  }]);

  return Webgl;
})();
"use strict";

window.onload = function () {
  var webgl = new Webgl();
};